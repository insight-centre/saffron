Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP , pages 593?601,
Suntec , Singapore , 27 August 2009. c?2009 ACL and AFNLP
Variational Decoding for Statistical Machine Translation
Zhifei Li and Jason Eisner and Sanjeev Khudanpur
Department of Computer Science and Center for Language and Speech Processing
Johns Hopkins University , Baltimore , MD 21218, USA
zhifei.work@gmail.com , jason@cs.jhu.edu , khudanpur@jhu.edu
Abstract
Statistical models in machine translation exhibit spurious ambiguity . That is , the probability of an output string is split among many distinct derivations ( e.g ., trees or segmentations ). In principle , the goodness of a string is measured by the total probability of its many derivations.
However , finding the best string ( e.g ., during decoding ) is then computationally intractable . Therefore , most systems use a simple Viterbi approximation that measures the goodness of a string using only its most probable derivation . Instead , we develop a variational approximation , which considers all the derivations but still allows tractable decoding . Our particular variational distributions are parameterized as ngram models . We also analytically show that interpolating these ngram models for different n is similar to minimum-risk decoding for BLEU ( Tromble et al , 2008). Experiments show that our approach improves the state of the art.
1 Introduction
Ambiguity is a central issue in natural language processing . Many systems try to resolve ambiguities in the input , for example by tagging words with their senses or choosing a particular syntax tree for a sentence . These systems are designed to recover the values of interesting latent variables , such as word senses , syntax trees , or translations , given the observed input.
However , some systems resolve too many ambiguities . They recover additional latent variables ? socalled nuisance variables?that are not of interest to the user.1 For example , though machine translation ( MT ) seeks to output a string , typical MT systems ( Koehn et al , 2003; Chiang , 2007) 1These nuisance variables may be annotated in training data , but it is more common for them to be latent even there , i.e ., there is no supervision as to their ? correct ? values.
will also recover a particular derivation of that output string , which specifies a tree or segmentation and its alignment to the input string . The competing derivations of a string are interchangeable for a user who is only interested in the string itself , so a system that unnecessarily tries to choose among them is said to be resolving spurious ambiguity.
Of course , the nuisance variables are important components of the system?s model . For example , the translation process from one language to another language may follow some hidden tree transformation process , in a recursive fashion . Many features of the model will crucially make reference to such hidden structures or alignments.
However , collapsing the resulting spurious ambiguity?i.e ., marginalizing out the nuisance variables?causes significant computational difficulties . The goodness of a possible MT output string should be measured by summing up the probabilities of all its derivations . Unfortunately , finding the best string is then computationally intractable ( Sima?an , 1996; Casacuberta and Higuera , 2000).2 Therefore , most systems merely identify the single most probable derivation and report the corresponding string . This corresponds to a Viterbi approximation that measures the goodness of an output string using only its most probable derivation , ignoring all the others.
In this paper , we propose a variational method that considers all the derivations but still allows tractable decoding . Given an input string , the original system produces a probability distribution p over possible output strings and their derivations ( nuisance variables ). Our method constructs a second distribution q ? Q that approximates p as well as possible , and then finds the best string according to q . The last step is tractable because each q ? Q is defined ( unlike p ) without reference to nuisance variables . Notice that q here does not approximate the entire translation process , but only 2May and Knight (2006) have successfully used tree-automaton determinization to exactly marginalize out some of the nuisance variables , obtaining a distribution over parsed translations . However , they do not marginalize over these parse trees to obtain a distribution over translation strings.
593 the distribution over output strings for a particular input . This is why it can be a fairly good approximation even without using the nuisance variables.
In practice , we approximate with several different variational families Q , corresponding to ngram ( Markov ) models of different orders . We geometrically interpolate the resulting approximations q with one another ( and with the original distribution p ), justifying this interpolation as similar to the minimum-risk decoding for BLEU proposed by Tromble et al (2008). Experiments show that our approach improves the state of the art.
The methods presented in this paper should be applicable to collapsing spurious ambiguity for other tasks as well . Such tasks include data-oriented parsing ( DOP ), applications of Hidden Markov Models ( HMMs ) and mixture models , and other models with latent variables . Indeed , our methods were inspired by past work on variational decoding for DOP ( Goodman , 1996) and for latent-variable parsing ( Matsuzaki et al , 2005).
2 Background 2.1 Terminology
In MT , spurious ambiguity occurs both in regular phrasebased systems ( e.g ., Koehn et al (2003)), where different segmentations lead to the same translation string ( Figure 1), and in syntaxbased systems ( e.g ., Chiang (2007)), where different derivation trees yield the same string ( Figure 2).
In the Hiero system ( Chiang , 2007) we are using , each string corresponds to about 115 distinct derivations on average.
We use x to denote the input string , and D(x ) to consider the set of derivations then considered by the system . Each derivation d ? D(x ) yields some translation string y = Y(d ) in the target language.
We write D(x , y ) def = { d ? D(x ) : Y(d ) = y } to denote the set of all derivations that yield y . Thus , the set of translations permitted by the model is
T(y ) def = { y : D(x , y ) 6= ?} ( or equivalently,
T(y ) def = { Y(d ) : d ? D(x )}). We write y ? for the translation string that is actually output.
2.2 Maximum A Posterior ( MAP ) Decoding
For a given input sentence x , a decoding method identifies a particular ? best ? output string y ?. The maximum a posteriori ( MAP ) decision rule is y ? = argmax y?T(x ) p(y | x ) (1) machine translation software ? ? ? ? ? ? machine translation software ? ? ? ? ? ? Figure 1: Segmentation ambiguity in phrasebased MT : two different segmentations lead to the same translation string.
S ->(? ?, machine ) S ->( ? , translation ) S ->( ? , software)
S ->(? ?, machine ) ?
S ->( ? , software)
S->(S0 S1, S0 S1)
S->(S0 S1, S0 S1)
S->(S0 ? S1, S0 translation S1)
Figure 2: Tree ambiguity in syntaxbased MT : two derivation trees yield the same translation string.
(An alternative decision rule , minimum Bayes risk ( MBR ), will be discussed in Section 4.) To obtain p(y | x ) above , we need to marginalize over a nuisance variable , the derivation of y.
Therefore , the MAP decision rule becomes y ? = argmax y?T(x ) ? d?D(x,y ) p(y , d | x ) (2) where p(y , d | x ) is typically derived from a loglinear model as follows , p(y , d | x ) = e??s(x,y,d)
Z(x ) = e??s(x,y,d ) ? y,d e ?? s(x,y,d ) (3) where ? is a scaling factor to adjust the sharpness of the distribution , the score s(x , y , d ) is a learned linear combination of features of the triple ( x , y , d ), and Z(x ) is a normalization constant.
Note that p(y , d | x ) = 0 if y 6= Y(d ). Our derivation set D(x ) is encoded in polynomial space , using a hypergraph or lattice.3 However , both | D(x )| and | T(x )| may be exponential in | x |. Since the marginalization needs to be carried out for each member of T(x ), the decoding problem of (2) turns out to be NP-hard,4 as shown by Sima?an (1996) for a similar problem.
3A hypergraph is analogous to a parse forest ( Huang and Chiang , 2007). ( A finite-state lattice is a special case .) It can be used to encode exponentially many hypotheses generated by a phrasebased MT system ( e.g ., Koehn et al (2003)) or a syntaxbased MT system ( e.g ., Chiang (2007)).
4Note that the marginalization for a particular y would be tractable ; it is used at training time in certain training objective functions , e.g ., maximizing the conditional likelihood of a reference translation ( Blunsom et al , 2008).
594 2.3 Viterbi Approximation
To approximate the intractable decoding problem of (2), most MT systems ( Koehn et al , 2003; Chiang , 2007) use a simple Viterbi approximation , y ? = argmax y?T(x ) pViterbi(y | x ) (4) = argmax y?T(x ) max d?D(x,y ) p(y , d | x ) (5) = Y ( argmax d?D(x ) p(y , d | x ) ) (6) Clearly , (5) replaces the sum in (2) with a max.
In other words , it approximates the probability of a translation string by the probability of its most-probable derivation . (5) is found quickly via (6).
The Viterbi approximation is simple and tractable , but it ignores most derivations.
2.4 Nbest Approximation ( or Crunching)
Another popular approximation enumerates the N best derivations in D(x ), a set that we call ND(x).
Modifying (2) to sum over only these derivations is called crunching by May and Knight (2006): y ? = argmax y?T(x ) pcrunch(y | x ) (7) = argmax y?T(x ) ? d?D(x,y)?ND(x ) p(y , d | x ) 3 Variational Approximate Decoding The Viterbi and crunching methods above approximate the intractable decoding of (2) by ignoring most of the derivations . In this section , we will present a novel variational approximation , which considers all the derivations but still allows tractable decoding.
3.1 Approximate Inference
There are several popular approaches to approximate inference when exact inference is intractable ( Bishop , 2006). Stochastic techniques such as Markov Chain Monte Carlo are exact in the limit of infinite runtime , but tend to be too slow for large problems . By contrast , deterministic variational methods ( Jordan et al , 1999), including message-passing ( Minka , 2005), are inexact but scale up well . They approximate the original intractable distribution with one that factorizes better or has a specific parametric form ( e.g ., Gaussian).
In our work , we use a fast variational method.
Variational methods generally work as follows.
When exact inference under a complex model p is intractable , one can approximate the posterior p(y | x ) by a tractable model q(y ), where q ? Q is chosen to minimize some information loss such as the KL divergence KL(p ? q ). The simpler model q can then act as a surrogate for p during inference.
3.2 Variational Decoding for MT
For each input sentence x , we assume that a baseline MT system generates a hypergraph HG(x ) that compactly encodes the derivation set D(x ) along with a score for each d ? D(x),5 which we interpret as p(y , d | x ) ( or proportional to it ). For any single y ? T(x ), it would be tractable using
HG(x ) to compute p(y | x ) = ? d p(y , d | x).
However , as mentioned , it is intractable to find argmaxy p(y | x ) as required by the MAP decoding (2), so we seek an approximate distribution q(y ) ? p(y | x).6 For a fixed x , we seek a distribution q ? Q that minimizes the KL divergence from p to q ( both regarded as distributions over y):7 q ? = argmin q?Q
KL(p ? q ) (8) = argmin q?Q ? y?T(x ) ( p log p ? p log q ) (9) = argmax q?Q ? y?T(x ) p log q (10) So far , in order to approximate the intractable optimization problem (2), we have defined another optimization problem (10). If computing p(y | x ) during decoding is computationally intractable , one might wonder if the optimization problem (10) is any simpler . We will show this is the case . The trick is to parameterize q as a factorized distribution such that the estimation of q ? and decoding using q ? are both tractable through efficient dynamic programs . In the next three subsections , we will discuss the parameterization , estimation , and decoding , respectively.
3.2.1 Parameterization of q
In (10), Q is a family of distributions . If we select a large family Q , we can allow more complex distributions , so that q ? will better approximate p . If we select a smaller family Q , we can 5The baseline system may return a pruned hypergraph , which has the effect of pruning D(x ) and T(x ) as well.
6Following the convention in describing variational inference , we write q(y ) instead of q(y | x ), even though q(y ) always depends on x implicitly.
7To avoid clutter , we denote p(y | x ) by p , and q(y ) by q.
We drop p log p from (9) because it is constant with respect to q . We then flip the sign and change argmin to argmax.
595 guarantee that q ? will have a simple form with many conditional independencies , so that q?(y ) and y ? = argmaxy q ?( y ) are easier to compute.
Since each q(y ) is a distribution over output strings , a natural choice for Q is the family of ngram models . To obtain a small KL divergence (8), we should make n as large as possible.
In fact , q ? ? p as n ? ?. Of course , this last point also means that our computation becomes intractable as n??.8 However , if p(y | x ) is defined by a hypergraph HG(x ) whose structure explicitly incorporates an mgram language model , both training and decoding will be efficient when m ? n . We will give algorithms for this case that are linear in the size of HG(x).9
Formally , each q ? Q takes the form q(y ) = ? w?W q(r(w ) | h(w))cw(y ) (11) where W is a set of ngram types . Each w ? W is an ngram , which occurs cw(y ) times in the string y , and w may be divided into an ( n ? 1)-gram prefix h(w ) ( the history ) and a 1gram suffix r(w ) ( the rightmost or current word).
8Blunsom et al (2008) effectively do take n = ?, by maintaining the whole translation string in the dynamic programming state . They alleviate the computation cost somehow by using aggressive beam pruning , which might be sensible for their relatively small task ( e.g ., input sentences of < 10 words ). But , we are interested in improving the performance for a largescale system , and thus their method is not a viable solution . Moreover , we observe in our experiments that using a larger n does not improve much over n = 2.
9A reviewer asks about the interaction with backed-off language models . The issue is that the most compact finite-state representations of these ( Allauzen et al , 2003), which exploit backoff structure , are not purely mgram for any m . They yield more compact hypergraphs ( Li and Khudanpur , 2008), but unfortunately those hypergraphs might not be treatable by Fig . 4?since where they back off to less than an ngram , e is not informative enough for line 8 to find w.
We sketch a method that works for any language model given by a weighted FSA , L . The variational family Q can be specified by any deterministic weighted FSA , Q , with weights parameterized by ?. One seeks ? to minimize (8).
Intersect HG(x ) with an ? unweighted ? version of Q in which all arcs have weight 1, so that Q does not prefer any string to another . By lifting weights into an expectation semiring ( Eisner , 2002), it is then possible to obtain expected transition counts in Q ( where the expectation is taken under p ), or other sufficient statistics needed to estimate ?.
This takes only time O(|HG(x )|) when L is a left-to-right refinement of Q ( meaning that any two prefix strings that reach the same state in L also reach the same state in Q ), for then intersecting L or HG(x ) with Q does not split any states . That is the case when L and Q are respectively pure mgram and ngram models withm ? n , as assumed in (12) and Figure 4. It is also the case when Q is a pure ngram model and L is constructed not to back off beyond ngrams ; or when the variational family Q is defined by deliberately taking the FSA Q to have the same topology as L.
The parameters that specify a particular q ? Q are the ( normalized ) conditional probability distributions q(r(w ) | h(w )). We will now see how to estimate these parameters to approximate p (? | x ) for a given x at test time.
3.2.2 Estimation of q?
Note that the objective function (8)?(10) asks us to approximate p as closely as possible , without any further smoothing . ( It is assumed that p is already smoothed appropriately , having been constructed from channel and language models that were estimated with smoothing from finite training data .) In fact , if p were the empirical distribution over strings in a training corpus , then q ? of (10) is just the maximum-likelihood ngram model?whose parameters , trivially , are just unsmoothed ratios of the ngram and ( n?1)-gram counts in the training corpus . That is , q?(r(w ) | h(w )) = c(w)c(h(w )) .
Our actual job is exactly the same , except that p is specified not by a corpus but by the hypergraph HG(x ). The only change is that the ngram counts c?(w ) are no longer integers from a corpus , but are expected counts under p:10 q?(r(w ) | h(w )) = c?(w ) c?(h(w )) = (12) ? y cw(y)p(y | x ) ? y ch(w)(y)p(y | x ) = ? y,d cw(y)p(y , d | x ) ? y,d ch(w)(y)p(y , d | x ) Now , the question is how to efficiently compute (12) from the hypergraph HG(x ). To develop the intuition , we first present a brute-force algorithm in Figure 3. The algorithm is brute-force since it first needs to unpack the hypergraph and enumerate each possible derivation in the hypergraph ( see line 1), which is computationally intractable.
The algorithm then enumerates each ngram and ( n ? 1)-gram in y and accumulates its soft count into the expected count , and finally obtains the parameters of q ? by taking count ratios via (12).
Figure 4 shows an efficient version that exploits the packed-forest structure of HG(x ) in computing the expected counts . Specifically , it first runs the insideoutside procedure , which annotates each node ( say v ) with both an inside weight ?( v ) and an outside weight ?( v ). The insideoutside also finds Z(x ), the total weight of all derivations.
With these weights , the algorithm then explores the hypergraph once more to collect the expected 10One can prove (12) via Lagrange multipliers , with q ?(? | h ) constrained to be a normalized distribution for each h.
596
Brute-Force-MLE(HG(x )) 1 for y , d in HG(x )  each derivation 2 forw in y  each ngram type 3  accumulate soft count 4 c?(w ) + = cw(y ) ? p(y , d | x ) 5 c?(h(w )) + = cw(y ) ? p(y , d | x ) 6 q ? ? MLE using formula (12) 7 return q ? Figure 3: Brute-force estimation of q?.
Dynamic-Programming-MLE(HG(x )) 1 run insideoutside on the hypergraph HG(x ) 2 for v in HG(x )  each node 3 for e ? B(v )  each incoming hyperedge 4 ce ? pe ? ?( v)/Z(x ) 5 for u ? T ( e )  each antecedent node 6 ce ? ce ? ?( u ) 7  accumulate soft count 8 forw in e  each ngram type 9 c?(w ) + = cw(e ) ? ce 10 c?(h(w )) + = cw(e ) ? ce 11 q ? ? MLE using formula (12) 12 return q ? Figure 4: Dynamic programming estimation of q ?. B(v ) represents the set of incoming hyperedges of node v ; pe represents the weight of the hyperedge e itself ; T ( e ) represents the set of antecedent nodes of hyperedge e . Please refer to the text for the meanings of other notations.
counts . For each hyperedge ( say e ), it first gets the posterior weight ce ( see lines 46). Then , for each ngram type ( say w ), it increments the expected count by cw(e ) ? ce , where cw(e ) is the number of copies of ngram w that are added by hyperedge e , i.e ., that appear in the yield of e but not in the yields of any of its antecedents u ? T ( e).
While there may be exponentially many derivations , the hypergraph data structure represents them in polynomial space by allowing multiple derivations to share subderivations . The algorithm of Figure 4 may be run over this packed forest in time O(|HG(x )|) where | HG(x )| is the hyper-graph?s size ( number of hyperedges).
3.2.3 Decoding with q?
When translating x at runtime , the q ? constructed from HG(x ) will be used as a surrogate for p during decoding . We want its most probable string : y ? = argmax y q?(y ) (13) Since q ? is an ngram model , finding y ? is equivalent to a shortest-path problem in a certain graph whose edges correspond to ngrams ( weighted with negative log-probabilities ) and whose vertices correspond to ( n ? 1)-grams.
However , because q ? only approximates p , y ? of (13) may be locally appropriate but globally inadequate as a translation of x . Observe , e.g ., that an ngram model q?(y ) will tend to favor short strings y , regardless of the length of x . Suppose x = le chat chasse la souris (? the cat chases the mouse ?) and q ? is a bigram approximation to p(y | x ). Presumably q?(the | START ), q?(mouse | the ), and q?(END | mouse ) are all large in HG(x ). So the most probable string y ? under q ? may be simply ? the mouse ,? which is short and has a high probability but fails to cover x.
Therefore , a better way of using q ? is to restrict the search space to the original hypergraph , i.e .: y ? = argmax y?T(x ) q?(y ) (14) This ensures that y ? is a valid string in the original hypergraph HG(x ), which will tend to rule out inadequate translations like ? the mouse .? If our sole objective is to get a good approximation to p(y | x ), we should just use a single ngram model q ? whose order n is as large as possible , given computational constraints . This may be regarded as favoring ngrams that are likely to appear in the reference translation ( because they are likely in the derivation forest ). However , in order to score well on the BLEU metric for MT evaluation ( Papineni et al , 2001), which gives partial credit , we would also like to favor lower-order ngrams that are likely to appear in the reference , even if this means picking some less-likely high-order ngrams . For this reason , it is useful to interpolate different orders of variational models , y ? = argmax y?T(x ) ? n ? n ? log q ? n(y ) (15) where n may include the value of zero , in which case log q?0(y ) def = | y |, corresponding to a conventional word penalty feature . In the geometric interpolation above , the weight ? n controls the relative veto power of the ngram approximation and can be tuned using MERT ( Och , 2003) or a minimum risk procedure ( Smith and Eisner , 2006).
Lastly , note that Viterbi and variational approximation are different ways to approximate the exact probability p(y | x ), and each of them has pros and cons . Specifically , Viterbi approximation uses the correct probability of one complete the hypergraph . In comparison , the variational approximation considers all the derivations in the hypergraph , but uses only aggregate statistics of fragments of derivations . Therefore , it is desirable to interpolate further with the Viterbi approximation when choosing the final translation output:11 y ? = argmax y?T(x ) ? n ? n ? log q ? n(y ) + ? v ? log pViterbi(y | x ) (16) where the first term corresponds to the interpolated variational decoding of (15) and the second term corresponds to the Viterbi decoding of (4).12 Assuming ? v > 0, the second term penalizes translations with no good derivation in the hypergraph.13
For n ? m , any of these decoders (14)? (16) may be implemented efficiently by using the ngram variational approximations q ? to rescore HG(x)?preserving its hypergraph topology , but modifying the hyperedge weights.14 While the original weights gave derivation d a score of log p(d | x ), the weights as modified for (16) will give d a score of ? n ? n ? log q ? n(Y(d )) + ? v ? log p(d | x ). We then find the best-scoring derivation and output its target yield ; that is , we find argmaxy?T(x ) via Y(argmaxd?D(x)).
4 Variational vs . MinRisk Decoding
In place of the MAP decoding , another commonly used decision rule is minimum Bayes risk ( MBR ): y ? = argmin y
R(y ) = argmin y ? y ? l(y , y?)p(y ? | x ) (17) 11It would also be possible to interpolate with the N - best approximations ( see Section 2.4), with some complications.
12Zens and Ney (2006) use a similar decision rule as here and they also use posterior ngram probabilities as feature functions , but their model estimation and decoding are over an N - best , which is trivial in terms of computation.
13Already at (14), we explicitly ruled out translations y having no derivation at all in the hypergraph . However , suppose the hypergraph were very large ( thanks to a large or smoothed translation model and weak pruning ). Then (14)?s heuristic would fail to eliminate bad translations (? the mouse ?), since nearly every string y ? ?? would be derived as a translation with at least a tiny probability . The ? soft ? version (16) solves this problem , since unlike the ? hard ? (14), it penalizes translations that appear only weakly in the hypergraph . As an extreme case , translations not in the hypergraph at all are infinitely penalized ( log pViterbi(y ) = log 0 = ??), making it natural for the decoder not to consider them , i.e ., to do only argmaxy?T(x ) rather than argmaxy ??? .
14One might also want to use the q?n or smoothed versions of them to rescore additional hypotheses , e.g ., hypotheses proposed by other systems or by system combination.
where l(y , y ?) represents the loss of y if the true answer is y ?, and the risk of y is its expected loss.15 Statistical decision theory shows MBR is optimal if p(y ? | x ) is the true distribution , while in practice p(y ? | x ) is given by a model at hand.
We now observe that our variational decoding resembles the MBR decoding of Tromble et al (2008). They use the following loss function , of which a linear approximation to BLEU ( Papineni et al , 2001) is a special case , l(y , y ?) = ?(?0|y |+ ? w?N ? wcw(y)?w(y ?)) (18) where w is an ngram type , N is a set of ngram types with n ? [1, 4], cw(y ) is the number of occurrence of the ngram w in y , and ? w(y ?) is an indicator function to check if y ? contains at least one occurrence of w . With the above loss function , Tromble et al (2008) derive the MBR rule16 y ? = argmax y (?0|y |+ ? w?N ? wcw(y)g(w | x )) (19) where g(w | x ) is a specialized ? posterior ? probability of the ngram w , and is defined as g(w | x ) = ? y ? ? w(y ?) p(y ? | x ) (20) Now , let us divide N , which contains ngram types of different n , into several subsets Wn , each of which contains only the ngrams with a given length n . We can now rewrite (19) as follows , y ? = argmax y ? n ? n ? gn(y | x ) (21) by assuming ? w = ?| w | and , gn(y | x )= { | y | if n = 0 ? w?Wn g(w | x)cw(y ) if n > 0 (22) Clearly , their rule (21) has a quite similar form to our rule (15), and we can relate (20) to (12) and (22) to (11). This justifies the use of interpolation in Section 3.2.3. However , there are several important differences . First , the ngram ? posterior ? of (20) is very expensive to compute . In fact , it requires an intersection between each ngram in the lattice and the lattice itself , as is done by Tromble 15The MBR becomes the MAP decision rule of (1) if a socalled zero-one loss function is used : l(y , y ?) = 0 if y = y ?; otherwise l(y , y ?) = 1.
16Note that Tromble et al (2008) only consider MBR for a lattice without hidden structures , though their method can be in principle applied in a hypergraph with spurious ambiguity.
598 et al (2008). In comparison , the optimal ngram probabilities of (12) can be computed using the insideoutside algorithm , once and for all . Also , g(w | x ) of (20) is not normalized over the history of w , while q?(r(w ) | h(w )) of (12) is . Lastly , the definition of the ngram model is different . While the model (11) is a proper probabilistic model , the function of (22) is simply an approximation of the average ngram precisions of y.
A connection between variational decoding and minimum-risk decoding has been noted before ( e.g ., Matsuzaki et al (2005)), but the derivation above makes the connection formal.
DeNero et al (2009) concurrently developed an alternate to MBR , called consensus decoding , which is similar to ours in practice although motivated quite differently.
5 Experimental Results
We report results using an open source MT toolkit , called Joshua ( Li et al , 2009), which implements
Hiero ( Chiang , 2007).
5.1 Experimental Setup
We work on a Chinese to English translation task.
Our translation model was trained on about 1M parallel sentence pairs ( about 28M words in each language ), which are subsampled from corpora distributed by LDC for the NIST MT evaluation using a sampling method based on the ngram matches between training and test sets in the foreign side . We also used a 5gram language model with modified Kneser-Ney smoothing ( Chen and Goodman , 1998), trained on a data set consisting of a 130M words in English Gigaword ( LDC2007T07) and the English side of the parallel corpora . We use GIZA ++ ( Och and Ney , 2000), a suffix-array ( Lopez , 2007), SRILM ( Stolcke , 2002), and risk-based deterministic annealing ( Smith and Eisner , 2006)17 to obtain word alignments , translation models , language models , and the optimal weights for combining these models , respectively . We use standard beam-pruning and cubepruning parameter settings , following Chiang (2007), when generating the hypergraphs.
The NIST MT?03 set is used to tune model weights ( e.g . those of (16)) and the scaling factor 17We have also experimented with MERT ( Och , 2003), and found that the deterministic annealing gave results that were more consistent across runs and often better.
Decoding scheme MT?04 MT?05
Viterbi 35.4 32.6
MBR ( K=1000) 35.8 32.7
Crunching ( N=10000) 35.7 32.8
Crunching+MBR ( N=10000) 35.8 32.7
Variational (1to4gram+wp+vt ) 36.6 33.5
Table 1: BLEU scores for Viterbi , Crunching , MBR , and variational decoding . All the systems improve significantly over the Viterbi baseline ( paired permutation test , p < 0.05). In each column , we boldface the best result as well as all results that are statistically indistinguishable from it . In MBR , K is the number of unique strings . For Crunching and Crunch-ing+MBR , N represents the number of derivations . On average , each string has about 115 distinct derivations . The variational method ?1to4gram+wp+vt ? is our full interpolation (16) of four variational ngram models (?1to4gram ?), the Viterbi baseline (? vt ?), and a word penalty feature (? wp?).
? of (3),18 and MT?04 and MT?05 are blind testsets . We will report results for lowercase BLEU4, using the shortest reference translation in computing brevity penalty.
5.2 Main Results
Table 1 presents the BLEU scores under Viterbi , crunching , MBR , and variational decoding . Both crunching and MBR show slight significant improvements over the Viterbi baseline ; variational decoding gives a substantial improvement.
The difference between MBR and Crunch-ing+MBR lies in how we approximate the distribution p(y ? | x ) in (17).19 For MBR , we take p(y ? | x ) to be proportional to pViterbi(y ? | x ) if y ? is among the K best distinct strings on that measure , and 0 otherwise . For Crunching+MBR , we take p(y ? | x ) to be proportional to pcrunch(y ? | x ), which is based on the N best derivations.
5.3 Results of Different Variational Decoding Table 2 presents the BLEU results under different ways in using the variational models , as discussed in Section 3.2.3. As shown in Table 2a , decoding with a single variational ngram model ( VM ) as per (14) improves the Viterbi baseline ( except the case with a unigram VM ), though often not statistically significant . Moreover , a bigram ( i.e ., ?2gram ?) achieves the best BLEU scores among the four different orders of VMs.
The interpolation between a VM and a word penalty feature (? wp ?) improves over the unigram 18We found the BLEU scores are not very sensitive to ?, contrasting to the observations by Tromble et al (2008).
19We also restrict T(x ) to { y : p(y | x ) > 0}, using the same approximation for p(y | x ) as we did for p(y ? | x).
599 ( a ) decoding with a single variational model
Decoding scheme MT?04 MT?05
Viterbi 35.4 32.6 1gram 25.9 24.5 2gram 36.1 33.4 3gram 36.0? 33.1 4gram 35.8? 32.9 ( b ) interpolation between a single variational model and a word penalty feature 1gram+wp 29.7 27.7 2gram+wp 35.5 32.6 3gram+wp 36.1? 33.1 4gram+wp 35.7? 32.8? ( c ) interpolation of a single variational model , the Viterbi model , and a word penalty feature 1gram+wp+vt 35.6? 32.8? 2gram+wp+vt 36.5? 33.5? 3gram+wp+vt 35.8? 32.9? 4gram+wp+vt 35.6? 32.8? ( d ) interpolation of several ngram VMs , the Viterbi model , and a word penalty feature 1to2gram+wp+vt 36.6? 33.6? 1to3gram+wp+vt 36.6? 33.5? 1to4gram+wp+vt 36.6? 33.5? Table 2: BLEU scores under different variational decoders discussed in Section 3.2.3. A star ? indicates a result that is significantly better than Viterbi decoding ( paired permutation test , p < 0.05). We boldface the best system and all systems that are not significantly worse than it . The brevity penalty BP in BLEU is always 1, meaning that on average y ? is no shorter than the reference translation , except for the ?1gram ? systems in ( a ), which suffer from brevity penalties of 0.826 and 0.831.
VM dramatically , but does not improve higher-order VMs ( Table 2b ). Adding the Viterbi feature (? vt ?) into the interpolation further improves the lower-order models ( Table 2c ), and all the improvements over the Viterbi baseline become statistically significant . At last , interpolation of several variational models does not yield much further improvement over the best previous model , but makes the results more stable ( Table 2d).
5.4 KL Divergence of Approximate Models
While the BLEU scores reported show the practical utility of the variational models , it is also interesting to measure how well each individual variational model q(y ) approximates the distribution p(y | x ). Ideally , the quality of approximation should be measured by the KL divergence
KL(p ? q ) def = H(p , q ) ? H(p ), where the crossentropy H(p , q ) def = ? ? y p(y | x ) log q(y ), and
Measure H(p , ?) Hd(p ) H(p ) bits/word q?1 q ? 2 q ? 3 q ? 4 ?
MT?04 2.33 1.68 1.57 1.53 1.36 1.03
MT?05 2.31 1.69 1.58 1.54 1.37 1.04
Table 3: Cross-entropies H(p , q ) achieved by various approximations q . The notation H denotes the sum of cross-entropies of all test sentences , divided by the total number of test words . A perfect approximation would achieve H(p ), which we estimate using the true Hd(p ) and a 10000-best list.
the entropy H(p ) def = ? ? y p(y | x ) log p(y | x).
Unfortunately H(p ) ( and hence KL = H(p , q ) ? H(p )) is intractable to compute . But , since H(p ) is the same for all q , we can simply use H(p , q ) to compare different models q . Table 3 reports the cross-entropies H(p , q ) for various models q.
We also report the derivational entropy
Hd(p ) def = ? ? d p(d | x ) log p(d | x).
20 From this , we obtain an estimate of H(p ) by observing that the ? gap ? Hd(p ) ? H(p ) equals Ep(y)[H(d | y )], which we estimate from our 10000-best list.
Table 3 confirms that higher-order variational models ( drawn from a larger family Q ) approximate p better . This is necessarily true , but it is interesting to see that most of the improvement is obtained just by moving from a unigram to a bigram model . Indeed , although Table 3 shows that better approximations can be obtained by using higher-order models , the best BLEU score in Tables 2a and 2c was obtained by the bigram model.
After all , p cannot perfectly predict the reference translation anyway , hence may not be worth approximating closely ; but p may do a good job of predicting bigrams of the reference translation , and the BLEU score rewards us for those.
6 Conclusions and Future Work
We have successfully applied the general variational inference framework to a largescale MT task , to approximate the intractable problem of MAP decoding in the presence of spurious ambiguity . We also showed that interpolating variational models with the Viterbi approximation can compensate for poor approximations , and that interpolating them with one another can reduce the Bayes risk and improve BLEU . Our empirical results improve the state of the art.
20Both H(p , q ) and Hd(p ) involve an expectation over exponentially many derivations , but they can be computed in time only linear in the size of HG(x ) using an expectation semiring ( Eisner , 2002). In particular , H(p , q ) can be found as ? ? d?D(x ) p(d | x ) log q(Y(d)).
600
Many interesting research directions remain open . To approximate the intractable MAP decoding problem of (2), we can use different variational distributions other than the ngram model of (11). Interpolation with other models is also interesting , e.g ., the constituent model in Zhang and Gildea (2008). We might also attempt to minimize KL(q ? p ) rather than KL(p ? q ), in order to approximate the mode ( which may be preferable since we care most about the 1best translation under p ) rather than the mean of p ( Minka , 2005). One could also augment our ngram models with nonlocal string features ( Rosenfeld et al , 2001) provided that the expectations of these features could be extracted from the hypergraph.
Variational inference can also be exploited to solve many other intractable problems in MT ( e.g ., word/phrase alignment and system combination).
Finally , our method can be used for tasks beyond MT . For example , it can be used to approximate the intractable MAP decoding inherent in systems using HMMs ( e.g . speech recognition ). It can also be used to approximate a contextfree grammar with a finite state automaton ( Nederhof , 2005).
References
Cyril Allauzen , Mehryar Mohri , and Brian Roark.
2003. Generalized algorithms for constructing statistical language models . In ACL , pages 40?47.
Christopher M . Bishop . 2006. Pattern recognition and machine learning . Springer.
Phil Blunsom , Trevor Cohn , and Miles Osborne . 2008.
A discriminative latent variable model for statistical machine translation . In ACL , pages 200?208.
Francisco Casacuberta and Colin De La Higuera . 2000.
Computational complexity of problems on probabilistic grammars and transducers . In ICGI , pages 15?24.
Stanley F . Chen and Joshua Goodman . 1998. An empirical study of smoothing techniques for language modeling . Technical report.
David Chiang . 2007. Hierarchical phrasebased translation . Computational Linguistics , 33(2):201?228.
John DeNero , David Chiang , and Kevin Knight . 2009.
Fast consensus decoding over translation forests . In
ACL-IJCNLP.
Jason Eisner . 2002. Parameter estimation for probabilistic finite-state transducers . In ACL , pages 1?8.
Joshua Goodman . 1996. Efficient algorithms for parsing the DOP model . In EMNLP , pages 143?152.
Liang Huang and David Chiang . 2007. Forest rescoring : Faster decoding with integrated language models . In ACL , pages 144?151.
M . I . Jordan , Z . Ghahramani , T . S . Jaakkola , and L . K.
Saul . 1999. An introduction to variational methods for graphical models . In Learning in Graphical
Models . MIT press.
Philipp Koehn , Franz Josef Och , and Daniel Marcu.
2003. Statistical phrasebased translation . In
NAACL , pages 48?54.
Zhifei Li and Sanjeev Khudanpur . 2008. A scalable decoder for parsing-based machine translation with equivalent language model state maintenance . In
ACL SSST , pages 10?18.
Zhifei Li , Chris Callison-Burch , Chris Dyer , Juri Ganitkevitch , Sanjeev Khudanpur , Lane Schwartz , Wren Thornton , Jonathan Weese , and Omar . Zaidan.
2009. Joshua : An open source toolkit for parsing-based machine translation . In WMT09, pages 135? 139.
Adam Lopez . 2007. Hierarchical phrasebased translation with suffix arrays . In EMNLPCoNLL , pages 976?985.
Takuya Matsuzaki , Yusuke Miyao , and Jun?ichi Tsujii.
2005. Probabilistic CFG with latent annotations . In
ACL , pages 75?82.
Jonathan May and Kevin Knight . 2006. A better nbest list : practical determinization of weighted finite tree automata . In NAACL , pages 351?358.
Tom Minka . 2005. Divergence measures and message passing . In Microsoft Research Technical Report ( MSR-TR-2005-173). Microsoft Research.
Mark-Jan Nederhof . 2005. A general technique to train language models on language models . Comput . Linguist ., 31(2):173?186.
Franz Josef Och and Hermann Ney . 2000. Improved statistical alignment models . In ACL , pages 440? 447.
Franz Josef Och . 2003. Minimum error rate training in statistical machine translation . In ACL , pages 160? 167.
Kishore Papineni , Salim Roukos , Todd Ward , and WeiJing Zhu . 2001. Bleu : a method for automatic evaluation of machine translation . In ACL , pages 311? 318.
Roni Rosenfeld , Stanley F . Chen , and Xiaojin Zhu.
2001. Whole-sentence exponential language models : A vehicle for linguistic-statistical integration.
Computer Speech and Language , 15(1).
Khalil Sima?an . 1996. Computational complexity of probabilistic disambiguation by means of tree-grammars . In COLING , pages 1175?1180.
David A . Smith and Jason Eisner . 2006. Minimum risk annealing for training loglinear models . In ACL , pages 787?794.
Andreas Stolcke . 2002. Srilm - an extensible language modeling toolkit . In ICSLP , pages 901?904.
Roy Tromble , Shankar Kumar , Franz Och , and Wolfgang Macherey . 2008. Lattice Minimum Bayes-Risk decoding for statistical machine translation . In
EMNLP , pages 620?629.
Richard Zens and Hermann Ney . 2006. Ngram posterior probabilities for statistical machine translation.
In WMT06, pages 72?77.
Hao Zhang and Daniel Gildea . 2008. Efficient multipass decoding for synchronous context free grammars . In ACL , pages 209?217.
601
