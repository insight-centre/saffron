Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP , pages 163?171,
Suntec , Singapore , 27 August 2009. c?2009 ACL and AFNLP
Efficient Minimum Error Rate Training and
Minimum Bayes-Risk Decoding for
Translation Hypergraphs and Lattices
Shankar Kumar1 and Wolfgang Macherey1 and Chris Dyer2 and Franz Och1
1Google Inc.
1600 Amphitheatre Pkwy.
Mountain View , CA 94043, USA
{shankarkumar,wmach,och}@google.com
2Department of Linguistics
University of Maryland
College Park , MD 20742, USA
redpony@umd.edu
Abstract
Minimum Error Rate Training ( MERT ) and Minimum Bayes-Risk ( MBR ) decoding are used in most current state-of-the-art Statistical Machine Translation ( SMT ) systems . The algorithms were originally developed to work with N - best lists of translations , and recently extended to lattices that encode many more hypotheses than typical N - best lists . We here extend lattice-based MERT and MBR algorithms to work with hypergraphs that encode a vast number of translations produced by
MT systems based on Synchronous Context Free Grammars . These algorithms are more efficient than the lattice-based versions presented earlier . We show how
MERT can be employed to optimize parameters for MBR decoding . Our experiments show speedups from MERT and
MBR as well as performance improvements from MBR decoding on several language pairs.
1 Introduction
Statistical Machine Translation ( SMT ) systems have improved considerably by directly using the error criterion in both training and decoding . By doing so , the system can be optimized for the translation task instead of a criterion such as likelihood that is unrelated to the evaluation metric . Two popular techniques that incorporate the error criterion are Minimum Error Rate Training ( MERT ) ( Och , 2003) and Minimum Bayes-Risk ( MBR ) decoding ( Kumar and Byrne , 2004).
These two techniques were originally developed for N - best lists of translation hypotheses and recently extended to translation lattices ( Macherey et al , 2008; Tromble et al , 2008) generated by a phrasebased SMT system ( Och and Ney , 2004).
Translation lattices contain a significantly higher number of translation alternatives relative to N - best lists . The extension to lattices reduces the runtimes for both MERT and MBR , and gives performance improvements from MBR decoding.
SMT systems based on synchronous context free grammars ( SCFG ) ( Chiang , 2007; Zollmann and Venugopal , 2006; Galley et al , 2006) have recently been shown to give competitive performance relative to phrasebased SMT . For these systems , a hypergraph or packed forest provides a compact representation for encoding a huge number of translation hypotheses ( Huang , 2008).
In this paper , we extend MERT and MBR decoding to work on hypergraphs produced by SCFG-based MT systems . We present algorithms that are more efficient relative to the lattice algorithms presented in Macherey et al (2008; Tromble et al (2008). Lattice MBR decoding uses a linear approximation to the BLEU score ( Papineni et al , 2001); the weights in this linear loss are set heuristically by assuming that ngram precisions decay exponentially with n . However , this may not be optimal in practice . We employ MERT to select these weights by optimizing BLEU score on a development set.
A related MBR-inspired approach for hypergraphs was developed by Zhang and Gildea (2008). In this work , hypergraphs were rescored to maximize the expected count of synchronous constituents in the translation . In contrast , our MBR algorithm directly selects the hypothesis in the hypergraph with the maximum expected approximate corpus BLEU score ( Tromble et al , 2008).
will soon announce
X1 X2
X1 X2
X1 X2
X1 X2
X1 X2
X1 its future in the
X1 its future in the
Suzuki soon its future in
X1 announces
Rally World Championship
Figure 1: An example hypergraph.
163 2 Translation Hypergraphs
A translation lattice compactly encodes a large number of hypotheses produced by a phrasebased SMT system . The corresponding representation for an SMT system based on SCFGs ( e.g . Chiang (2007), Zollmann and Venugopal (2006), Mi et al (2008)) is a directed hypergraph or a packed forest ( Huang , 2008).
Formally , a hypergraph is a pair H = ? V , E ? consisting of a vertex set V and a set of hyperedges E ? V ? ? V . Each hyperedge e ? E connects a head vertex h(e ) with a sequence of tail vertices T ( e ) = { v1, ..., vn }. The number of tail vertices is called the arity (| e |) of the hyperedge . If the arity of a hyperedge is zero , h(e ) is called a source vertex . The arity of a hypergraph is the maximum arity of its hyperedges . A hyperedge of arity 1 is a regular edge , and a hypergraph of arity 1 is a regular graph ( lattice ). Each hyperedge is labeled with a rule re from the SCFG . The number of nonterminals on the righthand side of re corresponds with the arity of e . An example without scores is shown in Figure 1. A path in a translation hypergraph induces a translation hypothesis E along with its sequence of SCFG rules D = r1, r2, ..., rK which , if applied to the start symbol , derives E . The sequence of SCFG rules induced by a path is also called a derivation tree for E.
3 Minimum Error Rate Training
Given a set of source sentences FS1 with corresponding reference translations RS1 , the objective of MERT is to find a parameter set ?? M1 which minimizes an automated evaluation criterion under a linear model : ?? M1 = argmin ? M1 ? SX s=1
Err `
Rs , E?(Fs ; ?
M 1 ) ? ff
E?(Fs ; ?
M 1 ) = argmax
E ? SX s=1 ? mhm(E , Fs ) ff .
In the context of statistical machine translation , the optimization procedure was first described in Och (2003) for N - best lists and later extended to phrase-lattices in Macherey et al (2008). The algorithm is based on the insight that , under a loglinear model , the cost function of any candidate translation can be represented as a line in the plane if the initial parameter set ? M1 is shifted along a direction dM1 . Let C = { E1, ..., EK } denote a set of candidate translations , then computing the best scoring translation hypothesis E ? out of C results in the following optimization problem:
E?(F ; ?) = argmax
E?C n (? M1 + ? ? d
M 1 ) > ? hM1 ( E,F ) o = argmax
E?C ?
X m ? mhm(E,F ) | { z } = a(E,F ) + ? ?
X m dmhm(E,F ) | { z } = b(E,F ) ff = argmax
E?C ? a(E,F ) + ? ? b(E,F ) | { z } (?) ? Hence , the total score (?) for each candidate translation E ? C can be described as a line with ? as the independent variable . For any particular choice of ?, the decoder seeks that translation which yields the largest score and therefore corresponds to the topmost line segment . If ? is shifted from ?? to +?, other translation hypotheses may at some point constitute the topmost line segments and thus change the decision made by the decoder . The entire sequence of topmost line segments is called upper envelope and provides an exhaustive representation of all possible outcomes that the decoder may yield if ? is shifted along the chosen direction . Both the translations and their corresponding line segments can efficiently be computed without incorporating any error criterion . Once the envelope has been determined , the translation candidates of its constituent line segments are projected onto their corresponding error counts , thus yielding the exact and unsmoothed error surface for all candidate translations encoded in C . The error surface can now easily be traversed in order to find that ?? under which the new parameter set ? M1 + ?? ? d
M 1 minimizes the global error.
In this section , we present an extension of the algorithm described in Macherey et al (2008) that allows us to efficiently compute and represent upper envelopes over all candidate translations encoded in hypergraphs . Conceptually , the algorithm works by propagating ( initially empty ) envelopes from the hypergraph?s source nodes bottom-up to its unique root node , thereby expanding the envelopes by applying SCFG rules to the partial candidate translations that are associated with the envelope?s constituent line segments.
To recombine envelopes , we need two operators : the sum and the maximum over convex polygons.
To illustrate which operator is applied when , we transform H = ? V , E ? into a regular graph with typed nodes by (1) marking all vertices v ? V with the symbol ? and (2) replacing each hyperedge e ? E , | e | > 1, with a small subgraph consisting of a new vertex v?(e ) whose incoming and outgoing edges connect the same head and tail nodes input : associative map a : V ? Env(V ), hyperarc e output : Minkowski sum of envelopes over T ( e ) for ( i = 0; i < | T ( e )|; ++ i ) { v = Ti(e ); pq.enqueue (? v , i , 0?); }
L = ?;
D = ? e , ?1 ? ? ? ?| e |? while (! pq.empty ()) { ? v , i , j ? = pq.dequeue (); ` = A[v][j];
D[i+1] = `. D ; if ( L.empty () ? L.back().x < `. x ) { if (0 < j ) { `. y += L.back().y - A[v][j-1].y ; `. m += L.back().m - A[v][j-1].m ; }
L.push_back(`);
L.back().D = D ; } else {
L.back().y += `. y;
L.back().m += `. m;
L.back().D[i+1] = `. D ; if (0 < j ) {
L.back().y -= A[v][j-1].y;
L.back().m -= A[v][j-1].m ; } } if (++ j < A[v].size ()) pq.enqueue (? v , i , j ?); } return L ; in the transformed graph as were connected by e in the original graph . The unique outgoing edge of v?(e ) is associated with the rule re ; incoming edges are not linked to any rule . Figure 2 illustrates the transformation for a hyperedge with arity 3. The graph transformation is isomorphic.
The rules associated with every hyperedge specify how line segments in the envelopes of a hyper-edge?s tail nodes can be combined . Suppose we have a hyperedge e with rule re : X ? aX1bX2c and T ( e ) = { v1, v2}. Then we substitute X1 and X2 in the rule with candidate translations associated with line segments in envelopes Env(v1) and
Env(v2) respectively.
To derive the algorithm , we consider the general case of a hyperedge e with rule re : X ? w1X1w2...wnXnwn+1. Because the righthand side of re has n nonterminals , the arity of e is | e | = n . Let T ( e ) = { v1, ..., vn } denote the tail nodes of e . We now assume that each tail node vi ? T ( e ) is associated with the upper envelope over all candidate translations that are induced by derivations of the corresponding nonterminal symbol Xi . These envelopes shall be de-
Algorithm 2 ?- operation ( Max ) input : array L[0..K-1] containing line objects output : upper envelope of L
Sort(L:m ); j = 0; K = size(L ); for ( i = 0; i < K ; ++ i ) { ` = L[i ]; `. x = -?; if (0 < j ) { if ( L[j-1].m == `. m ) { if (`. y <= L[j-1].y ) continue ; -- j ; } while (0 < j ) { `. x = (`. y - L[j-1].y )/ ( L[j-1].m - `. m ); if ( L[j-1].x < `. x ) break ; -- j ; } if (0 == j ) `. x = -?;
L[j ++] = `; } else L[j ++] = `; }
L.resize(j ); return L ; noted by Env(vi ). To decompose the problem of computing and propagating the tail envelopes over the hyperedge e to its head node , we now define two operations , one for either node type , to specify how envelopes associated with the tail vertices are propagated to the head vertex.
Nodes of Type ???: For a type ? node , the resulting envelope is the Minkowski sum over the envelopes of the incoming edges ( Berg et al ., 2008). Since the envelopes of the incoming edges are convex hulls , the Minkowski sum provides an upper bound to the number of line segments that constitute the resulting envelope : the bound is the sum over the number of line segments in the envelopes of the incoming edges , i.e .:? ? Env(v?(e )) ? ? ? ? v??T ( e ) ? ? Env(v ?) ? ?.
Algorithm 1 shows the pseudo code for computing the Minkowski sum over multiple envelopes.
The line objects ` used in this algorithm are encoded as 4-tuples , each consisting of the x-intercept with `? s left-adjacent line stored as `. x , the slope `. m , the y-intercept `. y , and the ( partial ) derivation tree `. D . At the beginning , the leftmost line segment of each envelope is inserted into a priority queue pq . The priority is defined in terms of a line?s x-intercept such that lower values imply higher priority . Hence , the priority queue enumerates all line segments from left to right in ascending order of their x-intercepts , which is the order needed to compute the Minkowski sum.
Nodes of Type ???: The operation performed = max Figure 2: Transformation of a hypergraph into a factor graph and bottom-up propagation of envelopes.
at nodes of type ??? computes the convex hull over the union of the envelopes propagated over the incoming edges . This operation is a ? max ? operation and it is identical to the algorithm described in ( Macherey et al , 2008) for phrase lattices . Algorithm 2 contains the pseudo code.
The complete algorithm then works as follows : Traversing all nodes in H bottom-up in topological order , we proceed for each node v ? V over its incoming hyperedges and combine in each such hyperedge e the envelopes associated with the tail nodes T ( e ) by computing their sum according to Algorithm 1 (?- operation ). For each incoming hyperedge e , the resulting envelope is then expanded by applying the rule re to its constituent line segments . The envelopes associated with different incoming hyperedges of node v are then combined and reduced according to Algorithm 2 (?- operation ). By construction , the envelope at the root node is the convex hull over the line segments of all candidate translations that can be derived from the hypergraph.
The suggested algorithm has similar properties as the algorithm presented in ( Macherey et al , 2008). In particular , it has the same upper bound on the number of line segments that constitute the envelope at the root node , i.e , the size of this envelope is guaranteed to be no larger than the number of edges in the transformed hypergraph.
4 Minimum Bayes-Risk Decoding
We first review Minimum Bayes-Risk ( MBR ) decoding for statistical MT . An MBR decoder seeks the hypothesis with the least expected loss under a probability model ( Bickel and Doksum , 1977). If we think of statistical MT as a classifier that maps a source sentence F to a target sentence E , the MBR decoder can be expressed as follows:
E ? = argmin
E??G ?
E?G
L(E,E?)P ( E|F ), (1) where L(E,E ?) is the loss between any two hypotheses E and E ?, P ( E|F ) is the probability model , and G is the space of translations ( N - best list , lattice , or a hypergraph).
MBR decoding for translation can be performed by reranking an N - best list of hypotheses generated by an MT system ( Kumar and Byrne , 2004).
This reranking can be done for any sentence-level loss function such as BLEU ( Papineni et al , 2001), Word Error Rate , or Position-independent
Error Rate.
Recently , Tromble et al (2008) extended
MBR decoding to translation lattices under an approximate BLEU score . They approximated log(BLEU ) score by a linear function of ngram matches and candidate length . If E and E ? are the reference and the candidate translations respectively , this linear function is given by:
G(E,E ?) = ?0|E ?|+ ? w ?| w|#w(E ?)? w(E ), (2) where w is an ngram present in either E or E ?, and ?0, ?1, ..., ? N are weights which are determined empirically , where N is the maximum ngram order.
Under such a linear decomposition , the MBR decoder ( Equation 1) can be written as
E ? = argmax
E??G ?0|E ?|+ ? w ?| w|#w(E ?) p(w|G ), (3) where the posterior probability of an ngram in the lattice is given by p(w|G ) = ?
E?G 1w(E)P ( E|F ). (4)
Tromble et al (2008) implement the MBR decoder using Weighted Finite State Automata ( WFSA ) operations . First , the set of ngrams is extracted from the lattice . Next , the posterior probability of each ngram is computed . A new automaton is then created by intersecting each ngram with weight ( from Equation 2) to an unweighted lattice . Finally , the MBR hypothesis is extracted as the best path in the automaton . We will refer to this procedure as FSAMBR.
The above steps are carried out one ngram at a time . For a moderately large lattice , there can be several thousands of ngrams and the procedure becomes expensive . We now present an alternate approximate procedure which can avoid this faster than FSAMBR.
4.1 Efficient MBR for lattices
The key idea behind this new algorithm is to rewrite the ngram posterior probability ( Equation 4) as follows : p(w|G ) = ?
E?G ? e?E f(e , w,E)P ( E|F ) (5) where f(e , w,E ) is a score assigned to edge e on path E containing ngram w : f(e , w,E ) = ? ? ? 1 w ? e , p(e|G ) > p(e?|G ), e ? precedes e on E 0 otherwise (6) In other words , for each pathE , we count the edge that contributes n-gramw and has the highest edge posterior probability relative to its predecessors on the path E ; there is exactly one such edge on each lattice path E.
We note that f(e , w,E ) relies on the full path E which means that it cannot be computed based on local statistics . We therefore approximate the quantity f(e , w,E ) with f?(e , w,G ) that counts the edge e with ngram w that has the highest arc posterior probability relative to predecessors in the entire lattice G . f?(e , w,G ) can be computed locally , and the ngram posterior probability based on f ? can be determined as follows : p(w|G ) =
X
E?G
X e?E f?(e , w,G)P ( E|F ) (7) =
X e?E 1w?ef ?( e , w,G)
X
E?G 1E(e)P ( E|F ) =
X e?E 1w?ef ?( e , w,G)P ( e|G ), where P ( e|G ) is the posterior probability of a lattice edge . The algorithm to perform Lattice MBR is given in Algorithm 3. For each node t in the lattice , we maintain a quantity Score(w , t ) for each ngram w that lies on a path from the source node to t . Score(w , t ) is the highest posterior probability among all edges on the paths that terminate on t and contain ngram w . The forward pass requires computing the ngrams introduced by each edge ; to do this , we propagate ngrams ( up to maximum order ?1) terminating on each node.
4.2 Extension to Hypergraphs
We next extend the Lattice MBR decoding algorithm ( Algorithm 3) to rescore hypergraphs produced by a SCFG based MT system . Algorithm 4 is an extension to the MBR decoder on lattices
Algorithm 3 MBR Decoding on Lattices 1: Sort the lattice nodes topologically.
2: Compute backward probabilities of each node.
3: Compute posterior prob . of each ngram : 4: for each edge e do 5: Compute edge posterior probability P ( e|G).
6: Compute ngram posterior probs . P ( w|G ): 7: for each ngram w introduced by e do 8: Propagate n ? 1 gram suffix to he.
9: if p(e|G ) > Score(w , T ( e )) then 10: Update posterior probs . and scores : p(w|G ) += p(e|G ) ? Score(w , T ( e)).
Score(w , he ) = p(e|G).
11: else 12: Score(w , he ) = Score(w , T ( e)).
13: end if 14: end for 15: end for 16: Assign scores to edges ( given by Equation 3).
17: Find best path in the lattice ( Equation 3).
(Algorithm 3). However , there are important differences when computing the ngram posterior probabilities ( Step 3). In this inside pass , we now maintain both ngram prefixes and suffixes ( up to the maximum order?1) on each hypergraph node.
This is necessary because unlike a lattice , new ngrams may be created at subsequent nodes by concatenating words both to the left and the right side of the ngram . When the arity of the edge is 2, a rule has the general form aX1bX2c , where X1 and X2 are sequences from tail nodes . As a result , we need to consider all new sequences which can be created by the crossproduct of the ngrams on the two tail nodes . E.g . if X1 = { c , cd , d } and X2 = { f , g }, then a total of six sequences will result . In practice , such a crossproduct is not pro-Algorithm 4 MBR Decoding on Hypergraphs 1: Sort the hypergraph nodes topologically.
2: Compute inside probabilities of each node.
3: Compute posterior prob . of each hyperedge P ( e|G).
4: Compute posterior prob . of each ngram : 5: for each hyperedge e do 6: Merge the ngrams on the tail nodes T ( e ). If the same ngram is present on multiple tail nodes , keep the highest score.
7: Apply the rule on e to the ngrams on T ( e).
8: Propagate n ? 1 gram prefixes/suffixes to he.
9: for each ngram w introduced by this hyperedge do 10: if p(e|G ) > Score(w , T ( e )) then 11: p(w|G ) += p(e|G ) ? Score(w , T ( e))
Score(w , he ) = p(e|G ) 12: else 13: Score(w , he ) = Score(w , T ( e )) 14: end if 15: end for 16: end for 17: Assign scores to hyperedges ( Equation 3).
18: Find best path in the hypergraph ( Equation 3).
167 hibitive when the maximum ngram order in MBR does not exceed the order of the ngram language model used in creating the hypergraph . In the latter case , we will have a small set of unique prefixes and suffixes on the tail nodes.
5 MERT for MBR Parameter
Optimization
Lattice MBR Decoding ( Equation 3) assumes a linear form for the gain function ( Equation 2).
This linear function contains n + 1 parameters ?0, ?1, ..., ? N , where N is the maximum order of the ngrams involved . Tromble et al (2008) obtained these factors as a function of ngram precisions derived from multiple training runs . However , this does not guarantee that the resulting linear score ( Equation 2) is close to the corpus BLEU . We now describe how MERT can be used to estimate these factors to achieve a better approximation to the corpus BLEU.
We recall that MERT selects weights in a linear model to optimize an error criterion ( e.g . corpus BLEU ) on a training set . The lattice MBR decoder ( Equation 3) can be written as a linear model : E ? = argmaxE??G ? N i=0 ? igi(E ?, F ), where g0(E ?, F ) = | E ?| and gi(E ?, F ) =? w:|w|=i # w(E ?) p(w|G).
The linear approximation to BLEU may not hold in practice for unseen test sets or language-pairs . Therefore , we would like to allow the decoder to backoff to the MAP translation in such cases . To do that , we introduce an additional feature function gN+1(E,F ) equal to the original decoder cost for this sentence . A weight assignment of 1.0 for this feature function and zeros for the other feature functions would imply that the MAP translation is chosen . We now have a total ofN+2 feature functions which we optimize using MERT to obtain highest BLEU score on a training set.
6 Experiments
We now describe our experiments to evaluate MERT and MBR on lattices and hypergraphs , and show how MERT can be used to tune MBR parameters.
6.1 Translation Tasks
We report results on two tasks . The first one is the constrained data track of the NIST Arabic-to-English ( aren ) and Chinese-to-English ( zhen ) translation task1. On this task , the parallel and the 1http://www.nist.gov/speech/tests/mt
Dataset # of sentences aren zhen dev 1797 1664 nist02 1043 878 nist03 663 919 Table 1: Statistics over the NIST dev/test sets.
monolingual data included all the allowed training sets for the constrained track . Table 1 reports statistics computed over these data sets . Our development set ( dev ) consists of the NIST 2005 eval set ; we use this set for optimizing MBR parameters . We report results on NIST 2002 and NIST 2003 evaluation sets.
The second task consists of systems for 39 language-pairs with English as the target language and trained on at most 300M word tokens mined from the web and other published sources . The development and test sets for this task are randomly selected sentences from the web , and contain 5000 and 1000 sentences respectively.
6.2 MT System Description
Our phrasebased statistical MT system is similar to the alignment template system described in ( Och and Ney , 2004; Tromble et al , 2008). Translation is performed using a standard dynamic programming beamsearch decoder ( Och and Ney , 2004) using two decoding passes . The first decoder pass generates either a lattice or an N - best list . MBR decoding is performed in the second pass.
We also train two SCFG-based MT systems : a hierarchical phrasebased SMT ( Chiang , 2007) system and a syntax augmented machine translation ( SAMT ) system using the approach described in Zollmann and Venugopal (2006). Both systems are built on top of our phrasebased systems . In these systems , the decoder generates an initial hypergraph or anN - best list , which are then rescored using MBR decoding.
6.3 MERT Results
Table 2 shows runtime experiments for the hypergraph MERT implementation in comparison with the phrase-lattice implementation on both the aren and the zhen system . The first two columns show the average amount of time in msecs that either algorithm requires to compute the upper envelope when applied to phrase lattices . Compared to the algorithm described in ( Macherey et al , 2008) which is optimized for phrase lattices , the hypergraph implementation causes a small increase in ( Macherey 2008) Suggested Alg.
aren zhen aren zhen phrase lattice 8.57 7.91 10.30 8.65 hypergraph ? ? 8.19 8.11 Table 2: Average time for computing envelopes.
running time . This increase is mainly due to the representation of line segments ; while the phrase-lattice implementation stores a single backpointer , the hypergraph version stores a vector of backpointers.
The last two columns show the average amount of time that is required to compute the upper envelope on hypergraphs . For comparison , we prune hypergraphs to the same density (# of edges per edge on the best path ) and achieve identical running times for computing the error surface.
6.4 MBR Results
We first compare the new lattice MBR ( Algorithm 3) with MBR decoding on 1000-best lists and FSAMBR ( Tromble et al , 2008) on lattices generated by the phrasebased systems ; evaluation is done using both BLEU and average runtime per sentence ( Table 3). Note that N - best MBR uses a sentence BLEU loss function . The new lattice MBR algorithm gives about the same performance as FSAMBR while yielding a 20X speedup.
We next report the performance of MBR on hypergraphs generated by Hiero/SAMT systems . Table 4 compares Hypergraph MBR ( HGMBR ) with MAP and MBR decoding on 1000 best lists . On some systems such as the Arabic-English SAMT , the gains from Hypergraph MBR over 1000-best MBR are significant . In other cases , Hypergraph MBR performs at least as well as N - best MBR.
In all cases , we observe a 7X speedup in runtime . This shows the usefulness of Hypergraph MBR decoding as an efficient alternative to N - best MBR.
6.5 MBR Parameter Tuning with MERT
We now describe the results by tuning MBR ngram parameters ( Equation 2) using MERT . We first compute N + 1 MBR feature functions on each edge of the lattice/hypergraph . We also include the total decoder cost on the edge as as additional feature function . MERT is then performed to optimize the BLEU score on a development set ; For MERT , we use 40 random initial parameters as well as parameters computed using corpus based statistics ( Tromble et al , 2008).
BLEU (%) Avg.
aren zhen time nist03 nist02 nist03 nist02 ( ms.)
MAP 54.2 64.2 40.1 39.0 -
N - best MBR 54.3 64.5 40.2 39.2 3.7
Lattice MBR
FSAMBR 54.9 65.2 40.6 39.5 3.7
LatMBR 54.8 65.2 40.7 39.4 0.2
Table 3: Lattice MBR for a phrasebased system.
BLEU (%) Avg.
aren zhen time nist03 nist02 nist03 nist02 ( ms.)
Hiero
MAP 52.8 62.9 41.0 39.8 -
N - best MBR 53.2 63.0 41.0 40.1 3.7
HGMBR 53.3 63.1 41.0 40.2 0.5
SAMT
MAP 53.4 63.9 41.3 40.3 -
N - best MBR 53.8 64.3 41.7 41.1 3.7
HGMBR 54.0 64.6 41.8 41.1 0.5
Table 4: Hypergraph MBR for Hiero/SAMT systems.
Table 5 shows results for NIST systems . We report results on nist03 set and present three systems for each language pair : phrasebased ( pb ), hierarchical ( hier ), and SAMT ; Lattice MBR is done for the phrasebased system while HGMBR is used for the other two . We select the MBR scaling factor ( Tromble et al , 2008) based on the development set ; it is set to 0.1, 0.01, 0.5, 0.2, 0.5 and 1.0 for the aren-phrase , aren-hier , aren-samt , zhen-phrase zhen-hier and zhen-samt systems respectively . For the multilanguage case , we train phrasebased systems and perform lattice MBR for all language pairs . We use a scaling factor of 0.7 for all pairs . Additional gains can be obtained by tuning this factor ; however , we do not explore that dimension in this paper . In all cases , we prune the lattices/hypergraphs to a density of 30 using forwardbackward pruning ( Sixtus and Ortmanns , 1999).
We consider a BLEU score difference to be a ) gain if is at least 0.2 points , b ) drop if it is at most -0.2 points , and c ) no change otherwise . The results are shown in Table 6. In both tables , the following results are reported : Lattice/HGMBR with default parameters (?5, 1.5, 2, 3, 4) computed using corpus statistics ( Tromble et al , 2008), Lattice/HGMBR with parameters derived from MERT both without/with the baseline model cost feature ( mert?b , mert+b ). For multilanguage systems , we only show the # of language-pairs with gains/no-changes/drops for each MBR variant with respect to the MAP translation.
169
We observed in the NIST systems that MERT resulted in short translations relative to MAP on the unseen test set . To prevent this behavior , we modify the MERT error criterion to include a sentence-level brevity scorer with parameter ?: BLEU+brevity (?). This brevity scorer penalizes each candidate translation that is shorter than the average length over its reference translations , using a penalty term which is linear in the difference between either length . We tune ? on the development set so that the brevity score of MBR translation is close to that of the MAP translation.
In the NIST systems , MERT yields small improvements on top of MBR with default parameters . This is the case for Arabic-English Hi-ero/SAMT . In all other cases , we see no change or even a slight degradation due to MERT.
We hypothesize that the default MBR parameters ( Tromble et al , 2008) are well tuned . Therefore there is little gain by additional tuning using
MERT.
In the multilanguage systems , the results show a different trend . We observe that MBR with default parameters results in gains on 18 pairs , no differences on 9 pairs , and losses on 12 pairs.
When we optimize MBR features with MERT , the number of language pairs with gains/no changes/-drops is 22/5/12. Thus , MERT has a bigger impact here than in the NIST systems . We hypothesize that the default MBR parameters are suboptimal for some language pairs and that MERT helps to find better parameter settings . In particular , MERT avoids the need for manually tuning these parameters by language pair.
Finally , when baseline model costs are added as an extra feature ( mert+b ), the number of pairs with gains/no changes/drops is 26/8/5. This shows that this feature can allow MBR decoding to backoff to the MAP translation . When MBR does not produce a higher BLEU score relative to MAP on the development set , MERT assigns a higher weight to this feature function . We see such an effect for 4 systems.
7 Discussion
We have presented efficient algorithms which extend previous work on lattice-based MERT ( Macherey et al , 2008) and MBR decoding ( Tromble et al , 2008) to work with hypergraphs . Our new MERT algorithm can work with both lattices and hypergraphs . On lattices , it achieves similar runtimes as the implementation
System BLEU (%)
MAP MBR default mert-b mert+b aren.pb 54.2 54.8 54.8 54.9 aren.hier 52.8 53.3 53.5 53.7 aren.samt 53.4 54.0 54.4 54.0 zhen.pb 40.1 40.7 40.7 40.9 zhen.hier 41.0 41.0 41.0 41.0 zhen.samt 41.3 41.8 41.6 41.7 Table 5: MBR Parameter Tuning on NIST systems
MBR wrt . MAP default mert-b mert+b # of gains 18 22 26 # of no-changes 9 5 8 # of drops 12 12 5 Table 6: MBR on Multilanguage systems.
described in Macherey et al (2008). The new Lattice MBR decoder achieves a 20X speedup relative to either FSAMBR implementation described in Tromble et al (2008) or MBR on 1000-best lists . The algorithm gives comparable results relative to FSAMBR . On hypergraphs produced by Hierarchical and Syntax Augmented MT systems , our MBR algorithm gives a 7X speedup relative to 1000-best MBR while giving comparable or even better performance.
Lattice MBR decoding is obtained under a linear approximation to BLEU , where the weights are obtained using ngram precisions derived from development data . This may not be optimal in practice for unseen test sets and language pairs , and the resulting linear loss may be quite different from the corpus level BLEU . In this paper , we have described how MERT can be employed to estimate the weights for the linear loss function to maximize BLEU on a development set . On an experiment with 40 language pairs , we obtain improvements on 26 pairs , no difference on 8 pairs and drops on 5 pairs . This was achieved without any need for manual tuning for each language pair . The baseline model cost feature helps the algorithm effectively back off to the MAP translation in language pairs where MBR features alone would not have helped.
MERT and MBR decoding are popular techniques for incorporating the final evaluation metric into the development of SMT systems . We believe that our efficient algorithms will make them more widely applicable in both SCFG-based and phrasebased MT systems.
170
References
M . Berg , O . Cheong , M . Krefeld , and M . Overmars , 2008. Computational Geometry : Algorithms and Applications , chapter 13, pages 290?296. Springer-
Verlag , 3rd edition.
P . J . Bickel and K . A . Doksum . 1977. Mathematical Statistics : Basic Ideas and Selected topics . Holden-
Day Inc ., Oakland , CA , USA.
D . Chiang . 2007. Hierarchical phrase based translation . Computational Linguistics , 33(2):201 ? 228.
M . Galley , J . Graehl , K . Knight , D . Marcu , S . DeNeefe , W . Wang , and I . Thayer . 2006. Scalable Inference and Training of Context-Rich Syntactic Translation Models . . In COLING/ACL , Sydney , Australia.
L . Huang . 2008. Advanced Dynamic Programming in Semiring and Hypergraph Frameworks . In COL-
ING , Manchester , UK.
S . Kumar and W . Byrne . 2004. Minimum Bayes-Risk Decoding for Statistical Machine Translation.
In HLTNAACL , Boston , MA , USA.
W . Macherey , F . Och , I . Thayer , and J . Uszkoreit.
2008. Lattice-based Minimum Error Rate Training for Statistical Machine Translation . In EMNLP,
Honolulu , Hawaii , USA.
H . Mi , L . Huang , and Q . Liu . 2008. Forest-Based Translation . In ACL , Columbus , OH , USA.
F . Och and H . Ney . 2004. The Alignment Template Approach to Statistical Machine Translation . Computational Linguistics , 30(4):417 ? 449.
F . Och . 2003. Minimum Error Rate Training in Statistical Machine Translation . In ACL , Sapporo , Japan.
K . Papineni , S . Roukos , T . Ward , and W . Zhu . 2001.
Bleu : a Method for Automatic Evaluation of Machine Translation . Technical Report RC22176 ( W0109-022), IBM Research Division.
A . Sixtus and S . Ortmanns . 1999. High Quality Word Graphs Using Forward-Backward Pruning . In
ICASSP , Phoenix , AZ , USA.
R . Tromble , S . Kumar , F . Och , andW.Macherey . 2008.
Lattice Minimum Bayes-Risk Decoding for Statistical Machine Translation . In EMNLP , Honolulu,
Hawaii.
H . Zhang and D . Gildea . 2008. Efficient Multipass Decoding for Synchronous Context Free Grammars.
In ACL , Columbus , OH , USA.
A . Zollmann and A . Venugopal . 2006. Syntax Augmented Machine Translation via Chart Parsing . In
HLTNAACL , New York , NY , USA.
171
